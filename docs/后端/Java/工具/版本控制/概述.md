# 版本控制

版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。

版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。

![wps1](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202406121102753.jpg)

**版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。**

没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。

**配置文件**：在计算机科学领域，配置文件是一种计算机文件，可以为一些计算机程序配置参数和初始设置。

## 软件配置管理 SCM

SCM (Software Configuration Management，软件配置管理) 是一种标识、组织和控制修改的技术。软件配置管理应用于整个软件工程过程。

在软件建立时变更是不可避免的，而变更加剧了项目中软件开发者之间的混乱。SCM活动的目标就是为了标识变更、控制变更、确保变更正确实现并向其他有关人员报告变更。从某种角度讲，SCM是一种标识、组织和控制修改的技术，目的是使错误降为最小并最有效地提高生产效率。

作为评价一个大中型软件开发过程是否正确，合理，有效的重要手段，CMM(Capability Maturity Model) 能力成熟度模型提供了不同等级的标准流程，对软件开发过程（流程）进行了约束和建议, 而作为CMM 2级的一个关键域（Key Practice Area，KPA），SCM软件在整个软件的开发活动中占有很重要的位置。

![image-20230513222216814](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/202307051535503.png)

## 版本控制系统 VCS

可以把一个版本控制系统（缩写VCS）理解为一个 "数据库"，在需要的时候，它可以帮你完整地保存一个项目的快照。当你需要查看一个之前的快照（称之为“版本”）时，版本控制系统可以显示出当前版本与上一个版本之间的所有改动的细节。

**作用**：

1. **协同态发**：团队协作共同完成同一个项目。
2. **版本管理**：以不断提升项目版本的方式逐步完成项目。
3. **数据备份**：开发中以版本控制的形式保存每一个历史版本。
4. **权限控制**：对团队开发人员进行不同的权限分配。
5. **分支管理**：允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。

## 版本控制内容

版本控制包括：检入检出控制、分支和合并、历史记录。

### 检入检出控制

软件开发人员对源文件的修改不能在软件配置管理库中进行，对源文件的修改依赖于基本的文件系统并在各自的工作空间下进行。为了方便软件开发，需要不同的软件开发人员组织各自的工作空间。一般说来，不同的工作空间由不同的目录表示，而对工作空间的访问，由文件系统提供的文件访问权限加以控制。

访问控制需要管理各个人员存取或修改一个特定软件配置对象的权限。开发人员能够从库中取出对应项目的配置项进行修改，并检入到软件配置库中，对版本进行“升级”；配置管理人员可以确定多余配置项并删除。

 同步控制的实质是版本的检入检出控制。检入就是把软件配置项从用户的工作环境存入到软件配置库的过程，检出就是把软件配置项从软件配置库中取出的过程。检人是检出的逆过程。同步控制可用来确保由不同的人并发执行的修改不会产生混乱。

### 分支和合并

版本分支以一个已有分支的特定版本为起点，但是独立发展的版本序列)的人工方法就是从主版本——称为主干上拷贝一份，并做上标记。在实行了版本控制后，版本的分支也是一份拷贝，这时的拷贝过程和标记动作由版本控制系统完成。版本合并(来自不同分支的两个版本合并为其中一个分支的新版本)有两种途径，一是将版本A的内容附加到版本B中；另一种是合并版本A和版本B的内容，形成新的版本C。

### 历史记录

版本的历史记录有助于对软件配置项进行审核，有助于追踪问题的来源。历史记录包括版本号、版本修改时间、版本修改者、版本修改描述等最基本的内容，还可以有其他一些辅助性内容，比如版本的文件大小和读写属性。

## 版本控制系统分类

纵观版本控制系统的发展历史，《Version Control By Example》一书的作者 Eric Sink 在他的书中对版本控制进行了分类，广义上讲，版本控制工具的历史可以分为三代：

| 代     | 网络   | 操作       | 并发性       | 示例                                                |
| :----- | :----- | :--------- | :----------- | :-------------------------------------------------- |
| 第一代 | 无     | 仅一个文件 | 锁定的       | RCS, SCCS                                           |
| 第二代 | 集中式 | 多文件     | 提交之前合并 | CVS, SourceSafe, Subversion, Team Foundation Server |
| 第三代 | 分布式 | 变更的集合 | 合并之前提交 | Bazaar, Git, Mercurial                              |

### 本地版本控制系统

第一代版本控制系统被称为**本地版本控制系统**。通过加锁将并发执行转换成顺序执行。 一次只能有一个人处理文件。具体流程如下：首先，应该把文件放在一个服务器上，方便使用者上传或下载文件；其次，任何人想对文件修改时，需要先把这个文件加锁，通过checkout指令，使得其他人无法修改；最后，当修改完成之后，需要释放锁，通过checkin指令，形成一个新的版本，存放到服务器端。

第一代版本控制系统主要有 RCS、SCCS（1972年发布）和 DSEE（被认为是 Atria ClearCase 的前身）。目前，有些项目还在使用！

> **悲观锁**  每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。

### 集中式版本控制系统

第二代版本控制系统被称为**集中式版本控制系统(Centralized Version Control Systems，CVCS)**，其对同步修改更加宽容，但有一个明显的限制，用户必须在允许提交之前将当前修订合并到他们的工作中。

集中化的版本控制系统诸如 CVS，svn 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到 这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。

![img](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/202307051614058.png)

这种做法带来了许多好处，现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统; 要远比在各个客户端上维护本地数据库来得轻松容易。

**事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。 如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。**

> ​    并不是说服务器故障了就没有办法写代码了,只是在服务器故障的情况下,编写的代码是没有办法得到保障的.试想 svn 中央服务器挂机一天.你还拼命写了一天代码,其中 12 点之前的代码都是高质量可靠的,而且有很多闪光点.而 12 点之后的代码由于你想尝试一个比较大胆的想法,将代码改的面目全非了.这样下来你 12 点之前做的工作也都白费了 有记录的版本只能是 svn 服务器挂掉时保存的版本!
>
> ​    注：单点故障（英语：single point of failure，缩写SPOF）是指系统中一点失效，就会让整个系统无法运作的部件，换句话说，单点故障即会整体故障。

**要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端偶然提取出来的保存在本地的某些快照数据就成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。 只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。**

由上图可看到，在集中式版本控制系统中，如果服务器嗝屁了，那么所有的开发者就只能干瞪眼了！因为，SVN 对于项目的管理是依赖于服务器中的中心仓库的！我们的更改必须要提交到服务器中的中心仓库。

> **乐观锁**  每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。   乐观锁一般会使用版本号机制或 CAS 算法实现。

### 分布式版本控制系统

第三代版本控制系统被称为**分布式版本控制系统（Distributed Version Control Systems，DVCS）**，其允许合并和提交分开。在每个使用者电脑上就有一个完整的数据仓库，没有网络依然可以使用。

在这类系统中，像 Git，BitKeeper 等，**客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来**。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本 地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份（Git团队对代码做了极致的压缩 最终需要的实际空间比svn多不了太多）。

由上图可看到，分布式版本控制系统也可以有个服务器端的仓库，用来同步各开发者的私有仓库！在分布式版本控制系统中，每个参与者的本地也会有一个完整的仓库。即使服务器端崩溃，我们仍然可以使用 Git（仅在本地仓库管理我们的代码），在网络具备时，再和服务器进行同步即可！

​    更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中分别和不同工作小组的人相互协作。

​     **分布式的版本控制系统在管理项目时存放的不是项目版本与版本之间的差异（集中式版本控制系统存储的是差异）.它存的是索引(所需磁盘空间很少 所以每个客户端都可以放下整个项目的历史记录)。**

![img](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/202307051615639.png)

​    **分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:**

​        断网的情况下也可以进行开发(因为版本控制是在本地进行的)

​        使用 github 进行团队协作,哪怕 github 挂了 每个客户端保存的也都是整个完整的项目(包含历史记录)

## 集中式版本控制系统和分布式版本控制系统区别

**集中化的版本控制系统**：诸如 CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本 (版本库是集中存放在中央服务器)，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。

这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。

集中式版本控制系统最大的问题就是必须联网才能工作，如果在局域网内，带宽够大，速度够快。如果在互联网上，遇到网速慢的话，可能提交耗费时间过多。如果中央服务器的单点故障服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。

![image-20230513222238089](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202305140056965.png)

分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。当任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。

和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷：

1. 服务器断网的情况下也可以进行开发 (因为版本控制是在本地进行的)

2. 每个客户端保存的也都是整个完整的项目 (包含历史记录，更加安全)

![image-20230513222257255](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202305140056279.png)

在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当"中央服务器"的电脑，但这个服务器的作用仅仅是用来方便"交换"大家的修改，没有它大家也一样干活，只是交换修改不方便而已。