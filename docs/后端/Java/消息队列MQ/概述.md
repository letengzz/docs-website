# 消息队列 概述

如果需要进行远程调用，那么一般可以通过发送HTTP请求来完成，但是可以使用第二种方式，就是消息队列，它能够将发送方发送的信息放入队列中，当新的消息入队时，会通知接收方进行处理，一般消息发送方称为**生产者**，接收方称为**消费者**。

![image-20220415165805716](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403092346318.jpg)

这样所有的请求，都可以直接丢到消息队列中，再由消费者取出，不再是直接连接消费者的形式了，而是加了一个中间商，这也是一种很好的**解耦**方案，并且在高并发的情况下，由于消费者能力有限，消息队列也能起到一个**削峰填谷**的作用，堆积一部分的请求，再由消费者来慢慢处理，而不会像直接调用那样请求蜂拥而至。

## 组成部分

- **消息队列**：消息队列通过先进先出（FIFO）的方式处理消息，允许生产者将消息发送到队列，然后消费者从队列中接收这些消息。
- **生产者**：生产者是发送消息到 MQ 的应用程序。
- **消费者**：消费者是从 MQ 队列中获取消息并对其进行处理的应用程序。消费者订阅一个或多个队列，并接收队列中的消息。

## 消息协议

[AMQP 协议](http://www.amqp.org)(高级消息协议，`Advanced Message Queuing Protocol`)，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。`Erlang`中的实现有`RabbitMQ`等。

JMS应用程序接口 (Java消息服务，`Java Message Service`)，是一个`Java`平台中关于面向消息中间件（`MOM`）的`API`，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。`Java`消息服务是一个与具体平台无关的`API`，绝大多数`MOM`提供商都对`JMS`提供支持。

**AMQP和JMS**

`MQ`是消息通信的模型，并发具体实现。现在实现`MQ`的有两种主流方式：`AMQP、JMS`。

两者间的区别和联系：

- `JMS`是定义了统一的接口，来对消息操作进行统一；`AMQP`是通过规定协议来统一数据交互的格式
- `JMS`限定了必须使用`Java`语言；`AMQP`只是协议，不规定实现方式，因此是跨语言的。
- `JMS`规定了两种消息模型；而`AMQP`的消息模型更加丰富

## 应用场景

### 异步处理

**下订单：下订单--》加积分--》发红包--》发手机短信**

下订单---向MQ 发消息--》积分系统，红包系统，手机短信系统接收消息

![img](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112355641.jpg) 

同步是阻塞的 (会造成等待)，异步是非阻塞的 (不会等待)，大流量高并发请求、批量数据传递，就可以采用异步处理，提升系统吞吐量。
****

用户注册后，需要发注册邮件和注册短信，传统的做法有两种：

1. 串行的方式：将注册信息写入数据库后，发送注册邮件，再发送注册短信，以上三个任务全部完成后才返回给客户端。这有一个问题是，邮件，短信并不是必须的，它只是一个通知，而这种做法让客户端等待没有必要等待的东西。

   ![image-20240311232925543](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112329108.png)

2. 并行的方式：将注册信息写入数据库后，发送邮件的同时，发送短信，以上三个任务完成后，返回给客户端，并行的方式能提高处理的时间。

   ![image-20240311233209913](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112355847.png)

假设三个业务节点分别使用50ms，串行方式使用时间150ms，并行使用时间100ms。虽然并性已经提高的处理时间，但是，邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功，应该是写入数据库后就返回。

引入消息队列后，把发送邮件，短信不是必须的业务逻辑异步处理。

![image-20240311233848419](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112355909.png)

由此可以看出，引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计)，引入消息队列后处理后，响应时间是串行的3倍，是并行的2倍。

### 系统解耦

多个系统之间，不需要直接交互，通过消息进行业务流转；

![img](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112355210.jpg)

场景：

> 双11是购物狂节，用户下单后，订单系统需要通知库存系统，传统的做法就是订单系统调用库存系统的接口。

![image-20240311234513900](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112355697.png)

这种做法有一个缺点:

- 当库存系统出现故障时，订单就会失败。
- 订单系统和库存系统高耦合。

**引入消息队列**：

![image-20240311234840707](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112355953.png)

订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。

库存系统：订阅下单的消息，获取下单消息，进行库操作。

就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失。 

### 流量削峰

高负载请求/任务的缓冲处理：

![img](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112356270.jpg)

流量削峰一般在秒杀活动中应用广泛：

> 秒杀活动，一般会因为流量过大，导致应用挂掉，为了解决这个问题，一般在应用前端加入消息队列。

作用：

1. 可以控制活动人数，超过此一定阀值的订单直接丢弃
2. 可以缓解短时间的高流量压垮应用 (应用程序按自己的最大处理能力获取订单)

![image-20240311235444656](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403112356241.png)

用户的请求，服务器收到之后，首先写入消息队列，加入消息队列长度超过最大值，则直接抛弃用户请求或跳转到错误页面。

秒杀业务根据消息队列中的请求信息，再做后续处理。 

### 日志处理 

主要是用kafka这个服务器来做；日志处理是指将消息队列用于在日志处理中，比如Kafka解决大量日志传输的问题：loger.info(.....)

ELK 日志处理解决方案：loger.error(.....) -->logstash收集消息--> 发送消息的kafka --> elastic search (es) -->Kibana ELK日志处理平台

## 消息队列优缺点

关于消息队列的优点也就是上面列举的，就是在特殊场景下有其对应的好处，**解耦、异步、削峰**。

缺点有以下几个：

- **系统可用性降低**
  系统引入的外部依赖越多，越容易挂掉。本来 A 系统调用 BCD 三个系统的接口就好了，但是 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，所以还需要考虑如何保证消息队列的高可用

- **系统复杂度提高**

  硬生生加个 MQ 进来，怎么[保证消息没有重复消费]？怎么[处理消息丢失的情况]？怎么保证消息传递的顺序性？

- **一致性问题**

  A 系统处理完了直接返回成功了，以为这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这样数据就不一致了。

所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。

## 常见MQ

常见消息队列：

* **ActiveMQ**：基于`JMS`
* **RabbitMQ**：基于`AMQP`协议，`erlang`语言开发，稳定性好，性能很强，吞吐量很高，支持多种协议，集群化，消息的可靠执行特性等优势，很适合企业的开发。
* **Kafka**：提供了超高的吞吐量，ms级别的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。
* **RocketMQ**：基于`JMS`，阿里巴巴推出的消息队列，经历过双十一的考验，单机吞吐量高，消息的高可靠性，扩展性强，支持事务等，但是功能不够完整，语言支持性较差。