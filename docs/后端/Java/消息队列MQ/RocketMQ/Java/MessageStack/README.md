# RocketMQ 消息堆积问题

一般认为单条队列消息差值>=10w时，算堆积问题。

## 出现堆积原因

1. 生产太快了：

   **解决办法**： 

   - 生产方可以做业务限流，限制其流速

   - 增加消费者数量，但是消费者数量<=队列数量

   - 适当的设置最大的消费线程数量 (根据`IO(2n)/CPU(n+1)`)

     > SpringBoot

     ```java
     @RocketMQMessageListener(
     	consumerTHread = 40
     )
     ```

     > Java

     ```java
     consumer.setConsumeThreadMax(40)
     ```

   - 动态扩容队列数量，从而增加消费者数量 (最好不要动)

     ![image-20240329173952412](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403291739875.png)

2. 消费者消费出现问题：

   **解决办法**：

   - 排查消费者程序的问题

## 事发时处理

RocketMQ 发生了消息积压， **事发时** 一般有两种处理方式：

- **增加消费者的数量**：如果 Topic 下的 Message Queue 有很多，可以通过 **增加消费者的数量** 来处理消息积压，如果 Topic 下的 Message Queue 有很多，那么每个消费者是会分配一个或多个 Message Queue 进行消费的，那么此时就可以通过增加消费者的数量，来加快该 Topic 中消息的消费速度
- **新建 Topic 进行消息迁移**：如果 Topic 下的 Message Queue 很少， 那么此时增加消费者的数量也没有用了，可以临时 **新创建一个 Topic** ，并且将该 Topic 的 Message Queue 设置多一点，再新创建一组消费者将原 Topic 中的消息转发到新 Topic 中，此时就可以对新 Topic 采用增加消费者数量的方式来处理消息积压了

### 增加消费者的数量

增加消费者的数量的话，可以通过 **增加机器** 或者在已有的机器上 **启动新的进程** 来实现

这里增加消费者的数量是有依据的，比如一个 Topic 下有 8 个 MessageQueue，那么最多将消费者数量增加到 8 个，因为 Topic 下一个队列只可以被同一消费者组的一个消费者消费，如果消费者的数量比 Topic 下的队列数量多的话，会有部分消费者分不到队列，因此消费者数量最多和 Topic 下的队列数量相同

### 提高单个消费者的并发线程数

除了增加消费者的数量来处理消息积压，还可以通过 **提高单个消费者的消费能力** ，来尽快处理消息，避免消息积压

提高单个消费者的消费并发线程，在 5.x 之前可以通过修改 DefaultMQPushConsumer 类中的 consumeThreadMin 、consumeThreadMax 来提高单个消费者的并发能力（调整消费者的线程池的线程数量），在 5.x 版本可以通过`PushConsumerBuilder.setConsumptionThreadCount()` 设置线程数，SimpleConsumer可以由业务线程自由增加并发，底层线程安全

## 提前预防

提前预防的话，主要可以从以下几个方面来考虑：

- **生产者**：对于生产者，可以进行限流，并且评估 Topic 峰值流量，合理设计 Topic 下的队列数量，添加异常监控，及时发现问题

- **存储端**：可以将次要消息转移

- **消费者**：对于消费者来说，可以进行 **降级** 处理：将消息先落库，再去异步处理，并且要合理地根据 Topic 的队列数量和应用性能来部署响应的消费者机器数量

- **上线前**：在上线前，采用灰度发布，先灰度小范围用户进行使用，没问题之后，再全量发布

## 跳过堆积

差值中的数据都会被清除(必须存在消费者)

![image-20240329173815741](https://cdn.jsdelivr.net/gh/letengzz/tc2/img202403291738505.png)

